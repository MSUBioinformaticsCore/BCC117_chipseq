---
title: "ChIP-seq analysis report"
author: "Stephanie Hickey, Ph.D."
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
params:
    project_dir: /mnt/research/bioinformaticsCore/projects/thomashowm/BCC117_chipseq
    lab: Thomashow Lab
    project_name: CAMTA3 at warm and long-term cold conditions
    reference_genome: Arabidopsis_thaliana.TAIR10 ensembl release 60
    data_link: https://michiganstate-my.sharepoint.com/:f:/g/personal/hickeys6_msu_edu/EvNb1u1ZEE5Op0RlfSQVOtsBo2l-JdveOYKbhLFZ6x69mg?e=Pc1SKw
---
```{r, echo=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, echo=FALSE)
```

```{r, echo=FALSE, results="asis"}
## parameterized text
cat("\n")
cat("#### Client:", params$lab, " \n")
cat("#### Project:", params$project_name, " \n")
cat("#### Reference Genome:", params$reference_genome, " \n")
cat("#### [Data Folder Link](",params$data_link,") \n")
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
#Set up
options(error = function() {
  sink(stderr())
  on.exit(sink(NULL))
  traceback(3, max.lines = 1L)
  if (!interactive()) {
    q(status = 1)
  }
})

set.seed(1)

library(tidyverse)
library(patchwork)
library(DiffBind)
library(DT)
library(htmltools)

#Set project directories
if(!dir.exists(params$project_dir)){dir.create(params$project_dir)}

results.dir = paste0(params$project_dir, "/results")
if(!dir.exists(results.dir)){dir.create(results.dir)}

data.dir = paste0(params$project_dir, "/data")
if(!dir.exists(data.dir)){dir.create(data.dir)}

plot.dir = paste0(results.dir, "/report_plots")
if(!dir.exists(plot.dir)){dir.create(plot.dir)}
```

## nf-core/chipseq pipeline

The [nf-core/chipseq v 2.1.0 pipeline](https://nf-co.re/chipseq/2.0.0/) was used to perform raw read QC, adapter trimming, read alignment, duplicate marking, read filtering, and peak calling. See the [pipeline documentation](https://nf-co.re/chipseq/2.1.0/) for more details. **Because nf-core/chipseq v 2.1.0 requires replicate numbers to be sequential, warm IP rep4 is listed as warm IP rep3.**

## Sequencing quality

We use [FastQC v. 0.12.1](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/) to assess the quailty of the squencing reads in each `.fastq`, and [MultiQC v. 1.23](https://multiqc.info/) to group the results from each file into one report. See the nf-core chipseq [output file description](https://nf-co.re/chipseq/2.1.0/docs/output/) to interpret the files in the MultiQC report. 

### Raw `.fastq` files

For paired end sequencing, each sample has one `.fastq` file containing forward reads (`R1`) and one `.fastq` file containing reverse reads (`R2`) per lane (`L00N`). 

See the quality report for raw reads in in the (raw) sections of the `multiqc_report.html` 

### Trimmed `.fastq` files

We used [cutadapt v 3.4](https://cutadapt.readthedocs.io/en/stable/) to remove contaminating Illumina adaptor sequences and trim low quality bases from the ends of reads. 

See the quality report for trimmed reads in the (trimmed) sections of the `multiqc_report.html` 

## Aligning reads to the reference genome

We use [bwa v 0.7.18-r1243-dirty](https://bio-bwa.sourceforge.net) to align reads to the reference genome. 

We remove identical, or duplicate, reads these using the [`MarkDuplicates`](https://gatk.broadinstitute.org/hc/en-us/articles/360037052812-MarkDuplicates-Picard-) tool in picard 3.2.0-1-g3948afb6b to avoid double counting the same read.

The plots below show the raw total number of sequences and the number of properly paired after filtering out reads with the following criteria: 
 
 * reads mapping to the mitochondria and chloroplast genomes (SAMtools, BEDTools)         
 * reads mapping to blacklisted regions (SAMtools, BEDTools)   
 * reads that are marked as duplicates (SAMtools)    
 * reads that are not marked as primary alignments (SAMtools)    
 * reads that are unmapped (SAMtools)    
 * reads that map to multiple locations (SAMtools)   
 * reads containing > 4 mismatches (BAMTools)    
 * reads that have an insert size > 2kb (BAMTools; paired-end only)    
 * reads that map to different chromosomes (Pysam; paired-end only)    
 * reads that aren't in FR orientation (Pysam; paired-end only)    
 * reads where only one read of the pair fails the above criteria (Pysam; paired-end only)   

**warm IP rep4 is listed as warm IP rep3.**
```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.width=15, fig.height=5}
# stats unfiltered
unfiltered = read.delim(paste0(results.dir, "/multiqc/narrow_peak/multiqc_data/samtools-stats-dp.yaml"), header=F)

chunk <- 14
n <- nrow(unfiltered)
samples = unfiltered[seq(1, n, chunk),]
samples = gsub("_T1:", "", samples)

stats = as.data.frame(unfiltered[-c(seq(1, n, chunk)),])
colnames(stats) = "stats"

chunk <- 13
n <- nrow(stats)
r  <- rep(1:ceiling(n/chunk),each=chunk)[1:n]

unfiltered_split <- split(stats,r)
names(unfiltered_split) = samples


for (i in 1:length(unfiltered_split)){
  
  unfiltered_split[[i]] = 
    unfiltered_split[[i]] %>%
    separate(col = stats, into = c("stat", "reads"), sep = ": ") %>%
    mutate(Sample = names(unfiltered_split)[i],
           Category = "RawTotal")

}

# stats filtered
filtered = read.delim(paste0(results.dir, "/multiqc/narrow_peak/multiqc_data/samtools-stats-dp-2.yaml"), header=F)
  
chunk <- 14
n <- nrow(filtered)
samples = filtered[seq(1, n, chunk),]
samples = gsub(":", "", samples)

stats = as.data.frame(filtered[-c(seq(1, n, chunk)),])
colnames(stats) = "stats"

chunk <- 13
n <- nrow(stats)
r  <- rep(1:ceiling(n/chunk),each=chunk)[1:n]

filtered_split <- split(stats,r)
names(filtered_split) = samples


for (i in 1:length(filtered_split)){
  
  filtered_split[[i]] = 
    filtered_split[[i]] %>%
    separate(col = stats, into = c("stat", "reads"), sep = ": ") %>%
    mutate(Sample = names(filtered_split)[i],
           Category = "Filtered")

}

filtered = 
  do.call(rbind, filtered_split) %>%
  mutate(stat = trimws(stat)) %>%
  filter(stat == "Properly paired")

unfiltered = 
  do.call(rbind, unfiltered_split) %>%
  mutate(stat = trimws(stat)) %>%
  filter(stat == "Total sequences")

stats = rbind(filtered, unfiltered)

stats$Category = factor(stats$Category, levels = c("RawTotal", "Filtered"))
stats$reads = as.numeric(stats$reads)
stats$Million = paste0(round(stats$reads), "M") 

p =
  ggplot(stats, aes(y = reads, 
                    x =  Sample,
                    fill = Category)) +
  geom_bar(position="dodge", stat="identity") +
  theme_classic() +
  theme(text = element_text(size = 16)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  geom_text(position = position_dodge(width = .9), aes(y=reads+5, fill=Category, label=Million, hjust=.5)) + 
  ggtitle("Number of reads") +
  ylab("number of reads (M)") 
 
ggsave(p, 
       file = paste0(plot.dir, "/mapping_counts_barplot.png"),
                     width = 15,
                     height = 5)

print(p)
```

# Peak calling with MACS3

When analyzing ChIP-seq data, we look for areas on the genome where reads in the IP sample pile up into peaks relative to the input sample, signifying TF binding. We used [macs3 v 3.0.1](https://github.com/macs3-project/MACS) to call peaks with FDR < 0.05.

### Results files

These files contain information about the peaks called by MACS3 for each sample.**warm IP rep4 is listed as warm IP rep3.**
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/macs3/narrow_peak"), pattern = ".xls", full.names = T)
paste0("results/macs3/", basename(files))
```

**Column descriptions**
The first 30 rows contain information about the analysis performed

 * `chr`: chromosome name   
 * `start`: the start position of a peak    
 * `end`: the end position of a peak   
 * `length`: length of the peak region    
 * `abs_summit`: absolute peak summit position        
 * `pileup`: pileup height at peak summit   
 * `-LOG10(pvalue)`: -log10(p-value) for the peak summit (e.g. p-value =1e-10, then this value should be 10)   
 * `fold_enrichment`: fold enrichment for this peak summit against random Poisson distribution with local lambda    
 * `-LOG10(qvalue)`: -log10(q-value) at peak summit. q-value is similar to FDR    
 * `name`: the peakID   

### Peak summary

The following plots show the number of peaks called for each sample with $qvalue < .05$. **warm IP rep4 is listed as warm IP rep3.**

```{r, message=FALSE, warning=FALSE, echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/macs3/narrow_peak"), 
                   pattern = ".narrowPeak$",
                   full.names=T)

peaks = lapply(files, read.delim, header=F)
peaks = do.call(rbind, peaks)

peaks =
  peaks %>%
  mutate(Condition = gsub("_IP.*", "", V4)) %>%
  mutate(Replicate = gsub("_peak.*", "", V4)) %>%
  mutate(Replicate = gsub(".*_IP_", "", Replicate)) 

p_list = list()

for(cond in unique(peaks$Condition)){

  p_list[[cond]] = 
    peaks %>%
    filter(Condition == cond) %>%
  ggplot(aes(Replicate)) +
  geom_bar(position="dodge", stat="count") +
  theme_classic() +
  theme(text = element_text(size = 16)) +
  geom_text(aes(label = after_stat(count)), 
            stat = "count", 
            vjust = 1.5, 
            colour = "white") +
  ylab("number of peaks") +
  ggtitle(cond)
}

p = wrap_plots(p_list)

ggsave(p, file = paste0(plot.dir, "/narrowPeak_barplot.png")) 
print(p)

```

We can see how similar each sample is to the other samples using a PCA plot. Replicate samples from the same condition should cluster together. 

```{r, message=FALSE, warning=FALSE, echo=FALSE}
samples = read.csv(paste0(data.dir, "/sample_sheets/DiffBind_sample_sheet_narrowPeak.csv"))

if(file.exists(paste0(plot.dir, "/replicateDBA.Rdata"))){
  
  load(paste0(plot.dir, "/replicateDBA.Rdata"))
  
} else {

dbaOb = dba(sampleSheet=samples, minOverlap = 1)
dbaOb <- dba.count(dbaOb)
dbaOb <- dba.normalize(dbaOb)
save(dbaOb, file = paste0(plot.dir, "/replicateDBA.Rdata"))  

}

pdf(paste0(plot.dir, "/peaks_pca.pdf"))
dba.plotPCA(dbaOb,label=DBA_REPLICATE)
dev.off()

dba.plotPCA(dbaOb,label=DBA_REPLICATE)
```

# Consensus peaks 

We used [consensusSeekeR v 1.30.0](https://www.sciencedirect.com/science/article/pii/S0888754321001531) to find reproducible peaks across replicates of the same condition. Peaks must occur in a least 2 replicates to be considered. The consensus peak region starts at start of the most upstream peak and ends at the end of the most downstream peak.

### Consensus files

These files contain information about the reproducible, or consensus, peaks identified by consensusSeekeR for each condition.
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/macs3/narrow_peak"), pattern = "_consensus.peaks", full.names = T)
paste0("/results/bwa/merged_library/macs3/narrow_peak/", basename(files))
```

**Column descriptions: `<condition>_consensus.peaks.bed`**

 1. chromosome name   
 2. the start position of a peak    
 3. the end position of a peak   
 4. the consensus peak ID      
 5. the -log10(q-value) from the constituent MACS3 peak with the lowest q-value   
 6. the strand, always "."    

**Column descriptions: `<condition>_consensus.peaks_info.csv`**

These files show which narrowPeaks were used to call each consensus peak. The following columns are from the individual narrowPeak files from each replicate in the condition:

 * `seqnames`: chromosome name   
 * `start`: the start position of a peak    
 * `end`: the end position of a peak   
 * `width:` peak width    
 * `strand:` always "."      
 * `name`: Peak ID      
 * `score:` Integer score for display. In IGV stronger peaks are darker       
 * `signalValue`: fold enrichment for this peak summit against random Poisson distribution with local lambda   
 * `-LOG10(pvalue)`: -log10(p-value) for the peak summit (e.g. p-value =1e-10, then this value should be 10)   
 * `-LOG10(qvalue)`: -log10(q-value) at peak summit. q-value is similar to FDR    
 * `peak:` The position of the peak summit with respect to `start`     
 
The following columns correspond to the consensus peaks:   

 * `consensus_seqnames:` consensus peak chromosome name     
 * `consensus_start:` consensus peak start    
 * `consensus_end:` consensus peak end      
 * `consensus_width:` consensus peak width       
 * `consensus_strand:` always "."   
 * `consensusID:` consensus peak ID       

### Consensus peaks summary

The following plot shows the number of consensus peaks called for each condition

```{r, message=FALSE, warning=FALSE, echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/macs3/narrow_peak"), 
                   pattern = "_consensus.peaks.bed",
                   full.names=T)

peaks = lapply(files, read.delim, header=F)

cond = gsub("_consensus.peaks.bed", "", basename(files))

for (i in 1:length(peaks)){
  peaks[[i]]$Condition = cond[i]
}

peaks = do.call(rbind, peaks)

p = 
  ggplot(peaks, aes(Condition)) +
  geom_bar(position="dodge", stat="count") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(text = element_text(size = 16)) +
  geom_text(aes(label = after_stat(count)), 
            stat = "count", 
            vjust = 1.5, 
            colour = "white") +
  ylab("number of peaks")
 
ggsave(p, file = paste0(plot.dir, "/consensus_peak_barplot.png")) 

print(p)
```

## Nearest gene annotation files

We used `annotatePeaks.pl` from [HOMER v4.7.2](http://homer.ucsd.edu/homer/ngs/annotation.html) to identify the nearest gene to each peak, and to find instances of the supplied motif sequence within each peak.

These files contain the annotation information for each peak
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/annotatePeaks"), pattern = "_consensus.peaks.bed.anno", full.names = T)
paste0("/results/annotatePeaks/", basename(files))
```

**Column descriptions**

1. `Peak ID`    
2. `Chromosome`   
3. `Start`: Peak start position   
4. `End`: Peak end position   
5. `Strand`: arbitrary, always positive   
6. `Peak Score`: all 0, no score for consensus peaks    
8. `Annotation`: i.e. Exon, Intron, ...   
9. `Detailed Annotation`: Exon, Intron etc. + CpG Islands, repeats, etc.   
10. `Distance to TSS`: Distance to nearest RefSeq TSS   
11. `Nearest PromoterID`: NCBI nucleotide ID    
12. `Entrez ID`: Nearest TSS Entrez Gene ID   
13. `Nearest Unigene`: Nearest TSS Unigene ID    
16. `Gene Name`: Nearest TSS Gene Symbol    

```{r, echo=FALSE}
anno = lapply(files, read.delim)
peakSet = basename(files)
peakSet = gsub(".anno", "", peakSet)

for(i in 1:length(anno)){
  
  anno[[i]] =
    anno[[i]] %>%
    mutate(PeakSet = peakSet[i]) %>%
    select(-Focus.Ratio.Region.Size, 
           -Nearest.Refseq,
           -Nearest.Ensembl,
           -Gene.Alias,
           -Gene.Description,
           -Gene.Type)
}
  
t_list <-
  lapply(anno, function(df) {
    colnames(df)[1] = "PeakID"
    cond <- unique(df$PeakSet)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)
```

## Gene ontology enrichment

We used [`topGO v2.54.0`](https://bioconductor.org/packages/release/bioc/html/topGO.html) with Fisher's exact test and the gene ontology annotations from the [`org.At.tair.db v3.18.0`](https://bioconductor.org/packages/release/data/annotation/html/org.At.tair.db.html) bioconductor annotation package to check for enrichment of genes related to specific biological processes, molecular functions, and cellular compartments among genes near ChIP peaks. Only GO terms with 5 > n genes > 200 were included. GO terms containing several hundred genes are often overly broad and, therefore, uninformative. 

### Gene Ontology enrichment files 

These files contain the enrichment scores and overlapping genes for genes near peaks for each gene ontology term with at least one overlapping gene.
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/geneset_enrichment"), pattern = "_consensus.peaks.bed.GO.csv", full.names = T)
paste0("/geneset_enrichment/", basename(files))
```

Significantly enriched ($FDR<.05$) gene ontology terms are shown below.

**Column description**

 * `GO.ID`: Gene ontology ID for the term   
 * `Term`: Name of the term
 * `Annotated`: The total number of genes annotated to the term  
 * `Signifcant`: The number of genes annotated to the term that also appear in the gene set of interest     
 * `Expected`: The number of genes randomly expected to overlap with the Annotated genes  
 * `pval`: The Fisher's exact test p-value for the overlap 
 * `FDR`: The Benjamini-Hochberg adjusted p-value for multiple comparisons (calculated across each ontology type listed in the `Ontology` column) 
 * `Ontology`: The ontology type that the term belongs to   
 
```{r, message=FALSE, warning=FALSE, echo=FALSE}

go = lapply(files, read.csv, row.names=1)

cond = gsub("_consensus.peaks.bed.GO.csv", "", basename(files))

for (i in 1:length(go)){
  go[[i]]$Condition = cond[i]
  go[[i]] = 
    go[[i]] %>%
    filter(FDR < .05)
}

t_list <-
  lapply(go, function(df) {
    cond <- unique(df$Condition)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)
```

## Motif Enrichment

We used the [`streme`](https://meme-suite.org/meme/doc/meme.html?man_type=web) and [`sea`](https://meme-suite.org/meme/doc/sea.html?man_type=web) from [MEME v5.4.1](https://meme-suite.org/meme/index.html) to discover novel, de novo motifs and find enrichment for known motifs, respectively.

Known motifs came from the [JASPAR 2018](https://jaspar2018.genereg.net/) core vertebrates non-redundant database, downloaded in meme format [here](https://meme-suite.org/meme/doc/download.html).

Each sample has one folder for de novo motifs and one folder for known motifs.

### De novo motif discovery

These are the first novel enriched motifs identified by `meme` for each condition. If a condition is not listed, no novel motifs were identified.

```{r, results="asis", echo=FALSE}
dir_names = list.dirs(paste0(results.dir, "/motif_enrichment"))
dir_names = dir_names[grep("consensus.peaks",dir_names)]
dir_names = dir_names[grep("denovo_motifs",dir_names)]

file_names = lapply(dir_names, list.files, pattern = "logo1.png", full.names=T)
file_names = unlist(file_names)

for(h in 1:length(file_names)){
   image_file<-paste('\n![',
                     basename(dirname(file_names[h])), 
                     '](',
                     file_names[h],
                     ')\n'
                     ,sep="") 
   cat('\n')
   cat(image_file)
   cat('\n')
}
```

These folders hold the de novo motif results
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/motif_enrichment"), pattern = "consensus.peaks.bed_denovo")
paste0("results/motif_enrichment/", files)
```

**Files in each folder**

 * `meme.html` - an HTML file that provides the results in an interactive, human-readable format    
 * `meme.txt` - a plain text file of the results for backwards compatibility with earlier versions of MEME   
 * `meme.xml` - an XML file that provides the results in a format designed for machine processing    
 * `logoN.png,.eps` - PNG and EPS images files containing sequence logos for each of the motifs found by MEME (where N is the motif number)   
 
### Known motif enrichment

The tables below show known motifs enriched in each peak set. If a peak set is not show, no significant enrichment (q-val < .05) was found. 
```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.width=15, fig.height=5}

dir_names = list.dirs(paste0(results.dir, "/motif_enrichment"))
dir_names = dir_names[grep("consensus.peaks",dir_names)]
dir_names = dir_names[grep("known_motifs",dir_names)]
file_names = lapply(dir_names, list.files, pattern = "sea.html", full.names=T)
file_names = unlist(file_names)
file_names = gsub(".html", ".tsv", file_names)

sea = lapply(file_names, read.delim, comment.char = '#')
sea = lapply(sea, function(x){y=filter(x, QVALUE < .05);y})
sea_row = unlist(lapply(sea, nrow))
sea_keep = which(sea_row > 0)
sea = sea[sea_keep]

condition = basename(dirname(file_names))
condition = gsub(".bed_known_motifs", "", condition)
names(sea) = condition

for(i in 1:length(sea)){
  
  sea[[i]] =
    sea[[i]] %>%
    mutate(DB = basename(DB), 
           PeakSet = condition[i]) %>%
    select(DB,PeakSet, ID, ALT_ID, CONSENSUS, QVALUE)
}
 

t_list <-
  lapply(sea, function(df) {
    cond <-unique(df$PeakSet)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)

```

These folders hold the known motif enrichment results
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/motif_enrichment"), pattern = "consensus.peaks.bed_known")
paste0("results/motif_enrichment/", files)
```

**Files in each folder**

 * `sea.html` - an HTML file that provides the results in an interactive, human-readable format   
 * `sea.tsv` - a TSV (tab-separated values) file that provides the results in a format suitable for parsing by scripts and viewing with Excel    
 * `sequences.tsv` - a TSV (tab-separated values) file that lists the true- and false-positive sequences identified by SEA    

# Condition-specific peaks

We used BEDTools v 2.31.0 to identify non-overlapping peaks between the consensus peak sets in each condition. **Advice** The cold-only peaks I visually inspected in IGV are not particularly strong peaks. I would put more weight on peaks with statistically significant differential binding in the DiffBind analysis.

### Condition-specific peak files

These files contain information about the reproducible, or consensus, peaks identified by consensusSeekeR for each condition.
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/macs3/narrow_peak"), pattern = "_only.consensus.bed", full.names = T)
paste0("/results/bwa/merged_library/macs3/narrow_peak/", basename(files))
```

**Column descriptions**

 1. chromosome name   
 2. the start position of a peak    
 3. the end position of a peak   
 4. the consensus peak ID      
 5. the -log10(q-value) from the constituent MACS3 peak with the lowest q-value   
 6. the strand, always "."    

### Condition-specific peak summary

The following plot shows the number of condition-specific peaks called for each condition

```{r, message=FALSE, warning=FALSE, echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/macs3/narrow_peak"), 
                   pattern = "_only.consensus.bed",
                   full.names=T)

peaks = lapply(files, read.delim, header=F)

cond = gsub("_only.consensus.bed", "", basename(files))

for (i in 1:length(peaks)){
  peaks[[i]]$Condition = cond[i]
}

peaks = do.call(rbind, peaks)

p = 
  ggplot(peaks, aes(Condition)) +
  geom_bar(position="dodge", stat="count") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(text = element_text(size = 16)) +
  geom_text(aes(label = after_stat(count)), 
            stat = "count", 
            vjust = 1.5, 
            colour = "white") +
  ylab("number of peaks")
 
ggsave(p, file = paste0(plot.dir, "/condition_specific_peak_barplot.png")) 

print(p)
```

## Nearest gene annotation files

We used `annotatePeaks.pl` from [HOMER v4.7.2](http://homer.ucsd.edu/homer/ngs/annotation.html) to identify the nearest gene to each peak, and to find instances of the supplied motif sequence within each peak.

These files contain the annotation information for each peak
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/annotatePeaks"), pattern = "_only.consensus.bed.anno", full.names = T)
paste0("/results/annotatePeaks/", basename(files))
```

**Column descriptions**

1. `Peak ID`    
2. `Chromosome`   
3. `Start`: Peak start position   
4. `End`: Peak end position   
5. `Strand`: arbitrary, always positive   
6. `Peak Score`: all 0, no score for consensus peaks    
8. `Annotation`: i.e. Exon, Intron, ...   
9. `Detailed Annotation`: Exon, Intron etc. + CpG Islands, repeats, etc.   
10. `Distance to TSS`: Distance to nearest RefSeq TSS   
11. `Nearest PromoterID`: NCBI nucleotide ID    
12. `Entrez ID`: Nearest TSS Entrez Gene ID   
13. `Nearest Unigene`: Nearest TSS Unigene ID    
16. `Gene Name`: Nearest TSS Gene Symbol    

```{r, echo=FALSE}
anno = lapply(files, read.delim)
peakSet = basename(files)
peakSet = gsub(".anno", "", peakSet)

for(i in 1:length(anno)){
  
  anno[[i]] =
    anno[[i]] %>%
    mutate(PeakSet = peakSet[i]) %>%
    select(-Focus.Ratio.Region.Size, 
           -Nearest.Refseq,
           -Nearest.Ensembl,
           -Gene.Alias,
           -Gene.Description,
           -Gene.Type)
}
  
t_list <-
  lapply(anno, function(df) {
    colnames(df)[1] = "PeakID"
    cond <- unique(df$PeakSet)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)
```

## Gene ontology enrichment

We used [`topGO v2.54.0`](https://bioconductor.org/packages/release/bioc/html/topGO.html) with Fisher's exact test and the gene ontology annotations from the [`org.At.tair.db v3.18.0`](https://bioconductor.org/packages/release/data/annotation/html/org.At.tair.db.html) bioconductor annotation package to check for enrichment of genes related to specific biological processes, molecular functions, and cellular compartments among genes near ChIP peaks. Only GO terms with 5 > n genes > 200 were included. GO terms containing several hundred genes are often overly broad and, therefore, uninformative. 

### Gene Ontology enrichment files 

These files contain the enrichment scores and overlapping genes for genes near peaks for each gene ontology term with at least one overlapping gene.
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/geneset_enrichment"), pattern = "_only.consensus.bed.GO.csv", full.names = T)
paste0("/geneset_enrichment/", basename(files))
```

Significantly enriched ($FDR<.05$) gene ontology terms are shown below.

**Column description**

 * `GO.ID`: Gene ontology ID for the term   
 * `Term`: Name of the term
 * `Annotated`: The total number of genes annotated to the term  
 * `Signifcant`: The number of genes annotated to the term that also appear in the gene set of interest     
 * `Expected`: The number of genes randomly expected to overlap with the Annotated genes  
 * `pval`: The Fisher's exact test p-value for the overlap 
 * `FDR`: The Benjamini-Hochberg adjusted p-value for multiple comparisons (calculated across each ontology type listed in the `Ontology` column) 
 * `Ontology`: The ontology type that the term belongs to   
 
```{r, message=FALSE, warning=FALSE, echo=FALSE}

go = lapply(files, read.csv, row.names=1)

cond = gsub("_consensus.peaks.bed.GO.csv", "", basename(files))

for (i in 1:length(go)){
  go[[i]]$Condition = cond[i]
  go[[i]] = 
    go[[i]] %>%
    filter(FDR < .05)
}

t_list <-
  lapply(go, function(df) {
    cond <- unique(df$Condition)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)
```

## Motif Enrichment

We used the [`streme`](https://meme-suite.org/meme/doc/meme.html?man_type=web) and [`sea`](https://meme-suite.org/meme/doc/sea.html?man_type=web) from [MEME v5.4.1](https://meme-suite.org/meme/index.html) to discover novel, de novo motifs and find enrichment for known motifs, respectively.

Known motifs came from the [JASPAR 2018](https://jaspar2018.genereg.net/) core vertebrates non-redundant database, downloaded in meme format [here](https://meme-suite.org/meme/doc/download.html).

Each sample has one folder for de novo motifs and one folder for known motifs.

### De novo motif discovery

These are the first novel enriched motifs identified by `meme` for each condition. If a condition is not listed, no novel motifs were identified.

```{r, results="asis", echo=FALSE}
dir_names = list.dirs(paste0(results.dir, "/motif_enrichment"))
dir_names = dir_names[grep("only.consensus",dir_names)]
dir_names = dir_names[grep("denovo_motifs",dir_names)]

file_names = lapply(dir_names, list.files, pattern = "logo1.png", full.names=T)
file_names = unlist(file_names)

for(h in 1:length(file_names)){
   image_file<-paste('\n![',
                     basename(dirname(file_names[h])), 
                     '](',
                     file_names[h],
                     ')\n'
                     ,sep="") 
   cat('\n')
   cat(image_file)
   cat('\n')
}
```

These folders hold the de novo motif results
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/motif_enrichment"), pattern = "only.consensus.bed_denovo")
paste0("results/motif_enrichment/", files)
```

**Files in each folder**

 * `meme.html` - an HTML file that provides the results in an interactive, human-readable format    
 * `meme.txt` - a plain text file of the results for backwards compatibility with earlier versions of MEME   
 * `meme.xml` - an XML file that provides the results in a format designed for machine processing    
 * `logoN.png,.eps` - PNG and EPS images files containing sequence logos for each of the motifs found by MEME (where N is the motif number)   
 
### Known motif enrichment

The tables below show known motifs enriched in each peak set. If a peak set is not show, no significant enrichment (q-val < .05) was found. 
```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.width=15, fig.height=5}

dir_names = list.dirs(paste0(results.dir, "/motif_enrichment"))
dir_names = dir_names[grep("only.consensus.bed",dir_names)]
dir_names = dir_names[grep("known_motifs",dir_names)]
file_names = lapply(dir_names, list.files, pattern = "sea.html", full.names=T)
file_names = unlist(file_names)
file_names = gsub(".html", ".tsv", file_names)

sea = lapply(file_names, read.delim, comment.char = '#')
sea = lapply(sea, function(x){y=filter(x, QVALUE < .05);y})
sea_row = unlist(lapply(sea, nrow))
sea_keep = which(sea_row > 0)
sea = sea[sea_keep]

condition = basename(dirname(file_names))
condition = gsub(".bed_known_motifs", "", condition)
names(sea) = condition

for(i in 1:length(sea)){
  
  sea[[i]] =
    sea[[i]] %>%
    mutate(DB = basename(DB), 
           PeakSet = condition[i]) %>%
    select(DB,PeakSet, ID, ALT_ID, CONSENSUS, QVALUE)
}
 

t_list <-
  lapply(sea, function(df) {
    cond <-unique(df$PeakSet)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)

```

These folders hold the known motif enrichment results
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/motif_enrichment"), pattern = "only.consensus.bed_known")
paste0("results/motif_enrichment/", files)
```

**Files in each folder**

 * `sea.html` - an HTML file that provides the results in an interactive, human-readable format   
 * `sea.tsv` - a TSV (tab-separated values) file that provides the results in a format suitable for parsing by scripts and viewing with Excel    
 * `sequences.tsv` - a TSV (tab-separated values) file that lists the true- and false-positive sequences identified by SEA    


# Diffbind

We used [DiffBind v3.8.4](https://bioconductor.org/packages/release/bioc/html/DiffBind.html) to identify peaks differentially bound between each pair of conditions. Specifically, for each pair of conditions, a union peakset was derived that includes peaks present in at least two samples. A custom greylist was built using the inputs for each sample the For each replicate of the two conditions, the reads within the union peak set are counted and normalized by the total read depth. Then, the normalized counts from each condition are compared to see if there is a significant difference (FDR < .05) in the number of reads within each peak between conditions. 

### Results files

These files contain the DiffBind results for each pair of conditions. 
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/diffbind"), pattern = ".csv", full.names = T)
paste0("results/diffbind/", basename(files))
```

**Column descriptions**

 * `Chr`: chromosome    
 * `Start`: peak start    
 * `End`: peak end    
 * `Conc`: The average normalized counts across all replicates of both conditions   
 * `Conc_Condition1`: The average normalized counts across condition 1. Very small numbers are reported as 0.       
 * `Conc_Condition2`: The average normalized counts across condition 2. Very small numbers are reported as 0.     
 * `Fold`: The log2(Conc_Condition1/Conc_Condition2) fold change. Negative indicates a decreased occupancy in condition 1 relative to condition 2       
 * `pvalue`: the fold change p-value calculated by `DESeq2`        
 * `Contrast`: The two conditions being compared    
 * `PeakID`: The id for the differential peak   
 * `Entrez.ID`: The Entrez.ID for the nearest gene TSS        
 * `Gene.Name`: The gene symbol for the nearest gene TSS    
 
```{r, message=FALSE, warning=FALSE, echo=FALSE}

db = lapply(files, read.csv, row.names=1)

cond = gsub(".csv", "", basename(files))

for (i in 1:length(db)){
  db[[i]]$Comparison = cond[i]
}

t_list <-
  lapply(db, function(df) {
    cond <- unique(df$Comparison)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)
``` 

### Differentially bound peak summary summary

The following plot shows the number of peaks with increased occupancy (gain) and decreased occupancy (loss) in Condition 1 relative to Condition 2.

```{r, message=FALSE, warning=FALSE, echo=FALSE}
files = list.files(paste0(results.dir, "/diffbind"), 
                   pattern = ".csv",
                   full.names=T)

peaks = lapply(files, read.csv, header=T)
peaks =lapply(peaks, function(x) {colnames(x)[c(6,7)] = c("Condition1", "Condition2"); x})
peaks = do.call(rbind, peaks)

peaks = 
  peaks %>%
  mutate(Direction = 
           case_when(
             Fold > 0 ~ "gain",
             Fold < 0 ~ "loss"
           ))

p = 
  ggplot(peaks, aes(Contrast, fill = Direction)) +
  geom_bar(position="dodge", stat="count") +
  theme_classic() +
  geom_text(aes(label = after_stat(count)), 
            stat = "count", 
            vjust = 1.5,
            position = position_dodge(width = 1)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(text = element_text(size = 16)) +
  theme(plot.margin = margin(1,1,1,1, "cm")) +
  ylab("number of peaks")
 
ggsave(p, file = paste0(plot.dir, "/diffbind_barplot.png")) 

print(p)
```

### Volcano Plots

Each dot in these volcano plots represents one union peak. The $log2(Condition1/Condition2)$ fold change is shown on the x-axis, and the $-log10(FDR)$ is show on the y-axis.

```{r, results="asis", echo=FALSE}
file_names = list.files(paste0(results.dir, "/diffbind"),
                        pattern = "volcano_plot.png",
                        full.names = T)

for(h in 1:length(file_names)){
   image_file<-paste('\n![',
                     basename(file_names[h]), 
                     '](',
                     file_names[h],
                     ')\n'
                     ,sep="") 
   cat('\n')
   cat(image_file)
   cat('\n')
}
```

### Profile plots

The following profile plot represents the binding affinity of the DNA-binding protein of interest within differentially bound peaks.

The X-axis shows the genomic position relative to the center of the peak. The color intensity of the Y-axis represent the normalized read count. A higher intensity means stronger binding or greater occupancy of that site.

```{r, results="asis", echo=FALSE}
file_names = list.files(paste0(results.dir, "/diffbind"),
                        pattern = "profile_plot.png",
                        full.names = T)

for(h in 1:length(file_names)){
   image_file<-paste('\n![',
                     basename(file_names[h]), 
                     '](',
                     file_names[h],
                     ')\n'
                     ,sep="") 
   cat('\n')
   cat(image_file)
   cat('\n')
}
```

## Nearest gene annotation files

We used `annotatePeaks.pl` from [HOMER v4.7.2](http://homer.ucsd.edu/homer/ngs/annotation.html) to identify the nearest gene to each peak, and to find instances of the supplied motif sequence within each peak.

These files contain the annotation information for each peak
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/annotatePeaks"), pattern = "_vs_", full.names = T)
files = files[grep(".anno$", files)]
paste0("results/annotatePeaks/", basename(files))
```

**Column descriptions**

1. `Peak ID`    
2. `Chromosome`   
3. `Start`: Peak start position   
4. `End`: Peak end position   
5. `Strand`: arbitrary, always positive   
6. `Peak Score`: all 0, no score for consensus peaks    
8. `Annotation`: i.e. Exon, Intron, ...   
9. `Detailed Annotation`: Exon, Intron etc. + CpG Islands, repeats, etc.   
10. `Distance to TSS`: Distance to nearest RefSeq TSS   
11. `Nearest PromoterID`: NCBI nucleotide ID    
12. `Entrez ID`: Nearest TSS Entrez Gene ID   
13. `Nearest Unigene`: Nearest TSS Unigene ID    
16. `Gene Name`: Nearest TSS Gene Symbol    

```{r, echo=FALSE}
anno = lapply(files, read.delim)
peakSet = basename(files)
peakSet = gsub(".anno", "", peakSet)

for(i in 1:length(anno)){
  
  anno[[i]] =
    anno[[i]] %>%
    mutate(PeakSet = peakSet[i]) %>%
    select(-Focus.Ratio.Region.Size, 
           -Nearest.Refseq,
           -Nearest.Ensembl,
           -Gene.Alias,
           -Gene.Description,
           -Gene.Type)
}
  
t_list <-
  lapply(anno, function(df) {
    colnames(df)[1] = "PeakID"
    cond <- unique(df$PeakSet)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)
```

## Gene ontology enrichment

We used [`topGO v2.50.0`](https://bioconductor.org/packages/release/bioc/html/topGO.html) with Fisher's exact test and the gene ontoloy annotations from the [`org.Hs.eg.db v3.16.0`](https://bioconductor.org/packages/release/data/annotation/html/org.Hs.eg.db.html) bioconductor annotation package to check for enrichment of genes related to specific biological processes, molecular functions, and cellular compartments among genes near ChIP peaks. Only GO terms with 5 > n genes > 200 were included. GO terms containing several hundred genes are often overly broad and, therefore, uninformative. 

### Gene Ontology enrichment files 

These files contain the enrichment scores and overlapping genes for genes near peaks for each gene ontology term with at least one overlapping gene.
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/geneset_enrichment"), pattern = "_consensus.peaks.bed.GO.csv", full.names = T)
paste0("/geneset_enrichment/", basename(files))
```

Significantly enriched ($FDR<.05$) gene ontology terms are shown below.

**Column description**

 * `GO.ID`: Gene ontology ID for the term   
 * `Term`: Name of the term
 * `Annotated`: The total number of genes annotated to the term  
 * `Signifcant`: The number of genes annotated to the term that also appear in the gene set of interest     
 * `Expected`: The number of genes randomly expected to overlap with the Annotated genes  
 * `pval`: The Fisher's exact test p-value for the overlap 
 * `FDR`: The Benjamini-Hochberg adjusted p-value for multiple comparisons (calculated across each ontology type listed in the `Ontology` column) 
 * `Ontology`: The ontology type that the term belongs to   
 
```{r, message=FALSE, warning=FALSE, echo=FALSE}

go = lapply(files, read.csv, row.names=1)

cond = gsub("_consensus.peaks.bed.GO.csv", "", basename(files))

for (i in 1:length(go)){
  go[[i]]$Condition = cond[i]
  go[[i]] = 
    go[[i]] %>%
    filter(FDR < .05)
}

t_list <-
  lapply(go, function(df) {
    cond <- unique(df$Condition)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)
``` 
 
## Motif Enrichment

We used the [`meme`](https://meme-suite.org/meme/doc/meme.html?man_type=web) and [`sea`](https://meme-suite.org/meme/doc/sea.html?man_type=web) from [MEME v5.4.1](https://meme-suite.org/meme/index.html) to discover novel, de novo motifs and find enrichment for known motifs, respectively.

Known motifs came from the [JASPAR 2018](https://jaspar2018.genereg.net/) core vertebrates non-redundant database, downloaded in meme format [here](https://meme-suite.org/meme/doc/download.html).

Each sample has one folder for de novo motifs and one folder for known motifs. Folders labeled "gain" or "loss" only contain peaks with a gain or loss of occupancy. Otherwise the file contains all significantly differentially bound peaks.

### De novo motif discovery

These are the first novel enriched motifs identified by `meme` for each condition. If a condition is not listed, no novel motifs were identified.

```{r, results="asis", echo=FALSE}
dir_names = list.dirs(paste0(results.dir, "/motif_enrichment"))
dir_names = dir_names[grep("_vs_",dir_names)]
dir_names = dir_names[grep("denovo_motifs",dir_names)]

file_names = lapply(dir_names, list.files, pattern = "logo1.png", full.names=T)
file_names = unlist(file_names)

for(h in 1:length(file_names)){
   image_file<-paste('\n![',
                     basename(dirname(file_names[h])), 
                     '](',
                     file_names[h],
                     ')\n'
                     ,sep="") 
   cat('\n')
   cat(image_file)
   cat('\n')
}
```

These folders hold the de novo motif results
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/motif_enrichment"), pattern = "_vs_")
files = files[grep("_denovo_motifs", files)]
paste0("results/motif_enrichment/", files)
```

**Files in each folder**

 * `meme.html` - an HTML file that provides the results in an interactive, human-readable format    
 * `meme.txt` - a plain text file of the results for backwards compatibility with earlier versions of MEME   
 * `meme.xml` - an XML file that provides the results in a format designed for machine processing    
 * `logoN.png,.eps` - PNG and EPS images files containing sequence logos for each of the motifs found by MEME (where N is the motif number)   
 
### Known motif enrichment

The tables below show known motifs enriched in each peak set. If a peak set is not show, no significant enrichment (q-val < .05) was found. 
```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.width=15, fig.height=5}

dir_names = list.dirs(paste0(results.dir, "/motif_enrichment"))
dir_names = dir_names[grep("_vs_",dir_names)]
dir_names = dir_names[grep("known_motifs",dir_names)]
file_names = lapply(dir_names, list.files, pattern = "sea.html", full.names=T)
file_names = unlist(file_names)
file_names = gsub(".html", ".tsv", file_names)

sea = lapply(file_names, read.delim, comment.char = '#')
sea = lapply(sea, function(x){y=filter(x, QVALUE < .05);y})
sea_row = unlist(lapply(sea, nrow))
sea_keep = which(sea_row > 0)
sea = sea[sea_keep]

condition = basename(dirname(file_names))
condition = gsub(".bed_known_motifs", "", condition)
names(sea) = condition

for(i in 1:length(sea)){
  
  sea[[i]] =
    sea[[i]] %>%
    mutate(DB = basename(DB), 
           PeakSet = condition[i]) %>%
    select(DB,PeakSet, ID, ALT_ID, CONSENSUS, QVALUE)
}
 

t_list <-
  lapply(sea, function(df) {
    cond <-unique(df$PeakSet)
    htmltools::tagList(htmltools::h4(cond),datatable(
      df,
      escape = F,
      rownames = F,
      filter = 'top')) })
    
htmltools::tagList(t_list)

```

These folders hold the known motif enrichment results
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/motif_enrichment"), pattern = "_vs_")
files = files[grep("_known_motifs", files)]
paste0("results/motif_enrichment/", files)
```

**Files in each folder**

 * `sea.html` - an HTML file that provides the results in an interactive, human-readable format   
 * `sea.tsv` - a TSV (tab-separated values) file that provides the results in a format suitable for parsing by scripts and viewing with Excel    
 * `sequences.tsv` - a TSV (tab-separated values) file that lists the true- and false-positive sequences identified by SEA    

# Viewing tracks with IGV

You can visually explore these data using the Broad Institute's Integrative Genomics Viewer ([IGV](https://software.broadinstitute.org/software/igv/))

### Pileup tracks

You can view read pileup tracks for each sample in IGV by loading the following files:
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/bigwig"), pattern = ".bw")
paste0("bigwig/", files)
```

The `control_lambda` files correspond to the input samples. As such, each `control_lambda` of the same condition is the same, regardless of replicate number. You can load one of these files per condition.

### MACS3 Peak tracks

You can view the locations of the peaks called by MACS3 individual replicates by loading these files:
```{r,echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/macs3/narrow_peak"), pattern = ".narrowPeak")
paste0("results/bwa/merged_library/macs3/narrow_peak/", files)
```

### Consensus Peak tracks

You can view the locations of the consensus peaks called by consensusSeekr by loading these files:
```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/bwa/merged_library/macs3/narrow_peak"), pattern = "consensus.peaks.bed")
paste0("peaks/", files)
```

### DiffBind Peak tracks

You can view the locations of differentially bound peaks called by DiffBind by loading these files:

```{r, echo=FALSE}
files = list.files(paste0(results.dir, "/diffbind"), pattern = "bed")
paste0("results/diffbind/", files)
```

### IGV session file

Alternatively, you can load all of the genome, peak, and bigwig files simultaneously in IGV by opening `results/igv/narrow_peak/igv_session.xml`. For this to work, all files must be kept in the original locations. 



